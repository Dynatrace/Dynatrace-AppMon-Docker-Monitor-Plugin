
 /**
  * This template file was generated by dynaTrace client.
  * The dynaTrace community portal can be found here: http://community.compuwareapm.com/
  * For information how to publish a plugin please visit http://community.compuwareapm.com/plugins/contribute/
  **/ 

package com.dynatrace.docker;

import java.io.IOException;
import java.math.BigInteger;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.node.ArrayNode;
import org.codehaus.jackson.node.BooleanNode;

import com.dynatrace.diagnostics.pdk.Monitor;
import com.dynatrace.diagnostics.pdk.MonitorEnvironment;
import com.dynatrace.diagnostics.pdk.MonitorMeasure;
import com.dynatrace.diagnostics.pdk.Plugin;
import com.dynatrace.diagnostics.pdk.Status;
import com.dynatrace.diagnostics.pdk.TaskEnvironment;
import com.dynatrace.docker.collector.DataCollector;
import com.dynatrace.docker.collector.TCPSocketDataCollector;
import com.dynatrace.docker.collector.UnixSocketDataCollector;
import com.dynatrace.docker.rest.config.ConnectionConfig;
import com.dynatrace.docker.rest.config.ServerConfig;
import com.dynatrace.docker.util.LibUtils;
import com.dynatrace.docker.util.Protocol;


/**
 * Main Monitor class.
 * 
 * @author Asad Ali

 *
 */

public class DockerMonitor implements Monitor {

	public static final Logger log = Logger.getLogger(DockerMonitor.class.getName());
	private static final String CONNECTION_TYPE = "connectionType";
	private static final String CONNECTION_TYPE_UNIX_SOCKET = "UNIX SOCKET";
	private static final String CONNECTION_TYPE_TCP_PORT = "TCP Port";
	private static final String SSH_OR_LOCAL = "sshOrLocal";
	private static final String DOCKER_HOSTS = "dockerHosts";
	public static final String SSH = "SSH";
	public static final String LOCAL = "Local";
	private static final String LOGIN_USER = "loginUser";
	private static final String PASSWORD = "password";
	private static final String DOCKER_PORT = "dockerPort";
	private static String[] METRICS_CONTAINER_INFO = {"containerCount", "imageCount"};
	private static String[] METRICS_CPU =  {"total_usage", "usage_in_usermode", "system_cpu_usage", "total_usage_delta", "usage_in_usermode_delta", "system_cpu_usage_delta","cpu_percentage"};
	private static String[] METRICS_MEMORY =  {"usage","limit","memoryUsage", "usage_delta"};
	private static String[] METRICS_NETWORK =  {"rx_bytes","tx_bytes","rx_packets", "tx_packets", "rx_bytes_delta", "tx_bytes_delta", "rx_packets_delta", "tx_packets_delta"};
	private DataCollector dataCollector;
	private HashMap<String, Double> cpuCache = new HashMap<String, Double>();
	private HashMap<String, Double> networkCache = new HashMap<String, Double>();
	private ArrayList<String> hosts = new ArrayList<String>();
	private String connectionType;
	private boolean libraryLoaded=false;

	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this
	 * scheduled Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link Plugin#teardown() teardown()} will be called
	 * next.
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * @param env
	 *            the configured <tt>MonitorEnvironment</tt> for this Plugin;
	 *            contains subscribed measures, but <b>measurements will be
	 *            discarded</b>
	 * @see Plugin#teardown()
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	
	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
        String hostList = env.getConfigString(DOCKER_HOSTS);
        if ( hostList == null || hostList.isEmpty()) {
        	return new Status(Status.StatusCode.ErrorTargetService, "No hosts list defined");
        }
        parseHostList(hostList);
        if (hosts.size() == 0) {
        	return new Status(Status.StatusCode.ErrorTargetService, "No hosts list defined");        	
        }
        log.log(Level.FINE, "Number of hosts=" + hosts.size());
		connectionType = env.getConfigString(CONNECTION_TYPE);
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Monitor Plugin to retrieve subscribed measures and store
	 * measurements.
	 *
	 * <p>
	 * This method is called at the scheduled intervals. If the Plugin execution
	 * takes longer than the schedule interval, subsequent calls to
	 * {@link #execute(MonitorEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link TaskEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link TaskEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 *
	 * @param env
	 *            a <tt>MonitorEnvironment</tt> object that contains the
	 *            Plugin configuration and subscribed measures. These
	*            <tt>MonitorMeasure</tt>s can be used to store measurements.
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status execute(MonitorEnvironment env) throws Exception {
		Map<String, Map<String, Map<String, Map<String, Double>>>> allContainers = new HashMap<String, Map<String, Map<String, Map<String, Double>>>>();
		int totalNumberOfContainers = 0;
		int totalNumberOfImages = 0;
		for ( String host:hosts) {			
			try {
				DataCollector dataCollector = getCollector(host, env);
				Map<String, Map<String, Map<String, Double>>> containersMap = new HashMap<String, Map<String, Map<String, Double>>>();
				JsonNode containerInfo = dataCollector.collectContainerAndImageCount(JsonNode.class);
				Map<String, Double> containerInfoMap = new HashMap<String, Double>();
				if ( containerInfo != null) {
					BigInteger noOfContainers = getBigIntegerValue("Containers", containerInfo);
					BigInteger noOfImages = getBigIntegerValue("Images", containerInfo);
					containerInfoMap.put(METRICS_CONTAINER_INFO[0], new Double(noOfContainers.doubleValue()));
					containerInfoMap.put(METRICS_CONTAINER_INFO[1], new Double(noOfImages.doubleValue()));
					totalNumberOfContainers += noOfContainers.intValue();
					totalNumberOfImages += noOfImages.intValue();
				}
				ArrayNode containers = dataCollector.collectContainerList(ArrayNode.class);
				// The key for the containersMap would be the containerName.
				// The value of the containersMap would be another Map that would have CPUGroup or MemoryGroup or NetworkGroup as the keys and the value
				// of this map would be another map (secondInnerMap). The key of the secondInnerMap would be metric name like usage, rx_bytes etc and the value
				// would be the actual value.
				log.log(Level.FINER, "Size=" + containers.size());
				if (containers != null)
				{
					for (JsonNode container : containers)
					{
						Map<String, Map<String, Double>> containerMap = new HashMap<String, Map<String, Double>>();
						String containerId = getStringValue("Id", container);
						String containerName = getContainerName(container);
						JsonNode containerStat = dataCollector.collectContainerData(containerId, JsonNode.class);
						log.log(Level.FINER, "Done getting all the data");
						populateContainerStat(containerStat, containerMap, containerName, host);
						containerMap.put("CIGroup", containerInfoMap);
						containersMap.put(containerName, containerMap);
					}
				}
				allContainers.put(host, containersMap);
			}
			catch (IOException ioe) {
				log.log(Level.SEVERE, ioe.getMessage());
				return new Status(Status.StatusCode.ErrorInternalException, ioe.getMessage());
			}
		}
		populateDockerMetrics(allContainers, totalNumberOfContainers, totalNumberOfImages, env);
		return new Status(Status.StatusCode.Success);		
	}

	private void parseHostList(String hostList) {
		String[] tokens = hostList.split(",");
		if ( tokens == null || tokens.length == 0) {
			return;
		}
		
		for (int i=0; i<tokens.length; i++) {
			hosts.add(tokens[i]);
		}
	}
	
	private DataCollector getCollector(String host, MonitorEnvironment env) throws Exception {
		if (connectionType.equals(CONNECTION_TYPE_TCP_PORT)) {
			String port = env.getConfigString(DOCKER_PORT);
			if ( port == null || port.equals("") ) {
				throw new Exception("Port number is not defined");
			}
			ConnectionConfig connectionConfig = new ConnectionConfig();
			connectionConfig.setHost(host);
			connectionConfig.setPort(new Integer(port).intValue());
			connectionConfig.setProtocol(Protocol.HTTP);
			ServerConfig serverConfig = new ServerConfig();
			serverConfig.setConnectionConfig(connectionConfig);
			dataCollector = new TCPSocketDataCollector(serverConfig);
		}
		else if (connectionType.equalsIgnoreCase(CONNECTION_TYPE_UNIX_SOCKET)) {
			String sshOrLocal = env.getConfigString(SSH_OR_LOCAL);
			UnixSocketDataCollector uCollector = new UnixSocketDataCollector();
			if (sshOrLocal.equals(SSH)) {
				String user = env.getConfigString(LOGIN_USER);
				String pass = env.getConfigPassword(PASSWORD);
				uCollector.setConnectionMode(SSH);
				uCollector.setHost(host);
				uCollector.setUser(user);
				uCollector.setPassword(pass);
				dataCollector = uCollector;
			}
			else {
				//Using junixsocket library to read data from the docker.sock file. Load the library once once.
				if ( !libraryLoaded) {
					final String arch = System.getProperty("os.arch");
					System.setProperty("org.newsclub.net.unix.library.path", System.getProperty("user.dir"));
					if (arch.contains("64")) {
						LibUtils.installNativeLibraryFromResources("libjunixsocket-linux-1.5-amd64.so");
					}
					else {
						LibUtils.installNativeLibraryFromResources("libjunixsocket-linux-1.5-i386.so");					
					}
					libraryLoaded=true;
				}
				uCollector.setConnectionMode(LOCAL);
				dataCollector = uCollector;
			}
		}
		
		return dataCollector;

	}
	private String getStringValue(String propertyName, JsonNode node)
	{
		JsonNode jsonNode = node.get(propertyName);
		if (jsonNode != null) {
			return jsonNode.getTextValue();
		}
		return null;
	}
	  
	private String getContainerName(JsonNode container)
	{
		ArrayNode containerNames = (ArrayNode)container.get("Names");
		if ((containerNames != null) && (containerNames.size() > 0)) {
			return containerNames.get(0).getTextValue();
		}
		return getStringValue("Id", container);
	}

	private void populateContainerStat(JsonNode node, Map<String, Map<String, Double>> containerMap, String containerName, String host) {
		getMemoryUsage(node, containerMap);
		getCPUUsage(node, containerMap, containerName, host);
		getNetworkUsage(node, containerMap, containerName, host);
	}

	private BigInteger getBigIntegerValue(String propertyName, JsonNode node)
	{
		JsonNode jsonNode = node.get(propertyName);
		if (jsonNode != null)
		{
			if ((jsonNode instanceof BooleanNode))
			{
				BooleanNode booleanNode = (BooleanNode)jsonNode;
				return booleanNode.getBooleanValue() ? BigInteger.ONE : BigInteger.ZERO;
			}
			return jsonNode.getBigIntegerValue();
		}
		return null;
	}

	private void getMemoryUsage(JsonNode node, Map<String, Map<String, Double>> theMap)
	{
		Map<String, Double> innerMap = new HashMap<String, Double>();
		JsonNode stats = node.get("memory_stats");
		if (stats != null)
		{
			BigInteger usage = getBigIntegerValue("usage", stats);
			BigInteger limit = getBigIntegerValue("limit", stats);
			
			innerMap.put(METRICS_MEMORY[0],new Double(usage.doubleValue()));
			innerMap.put(METRICS_MEMORY[1], new Double(limit.doubleValue()));
			if ((usage != null) && (limit != null)) {
				innerMap.put(METRICS_MEMORY[2], percentage(usage.doubleValue(), limit.doubleValue()));
			} else {
				log.log(Level.INFO, "Cannot calculate Memory %, usage=" + usage +", " + "limit=" + limit);
			}
			theMap.put("MemoryGroup", innerMap);
		}
	}
	  
	private void getCPUUsage(JsonNode node, Map<String, Map<String, Double>> theMap, String containerName, String host)
	{
		Map<String, Double> innerMap = new HashMap<String, Double>();
		JsonNode stats = node.get("cpu_stats");
		JsonNode cpuUsage;
		if ((stats != null) && ((cpuUsage = stats.get("cpu_usage")) != null))
		{
			JsonNode percpuUsage = cpuUsage.get("percpu_usage");
//			log.log(Level.SEVERE, "# of CPUs=" + percpuUsage.size());;
			log.log(Level.FINER, "CPUUsage=" + cpuUsage.toString());
			BigInteger totalUsage = getBigIntegerValue("total_usage", cpuUsage);
			BigInteger userModeUsage = getBigIntegerValue("usage_in_usermode", cpuUsage);
			BigInteger systemUsage = getBigIntegerValue("system_cpu_usage", stats);
			innerMap.put(METRICS_CPU[0], new Double(totalUsage.doubleValue()));
			innerMap.put(METRICS_CPU[1], new Double(userModeUsage.doubleValue()));
			innerMap.put(METRICS_CPU[2], new Double(systemUsage.doubleValue()));
			String cpuCacheTotalUsageKey = host + "|" + containerName + "|" + METRICS_CPU[0];
			Double prevTotalCPUUsage = cpuCache.get(cpuCacheTotalUsageKey);
			String cpuCacheUsageInUsermodeKey = host + "|" + containerName + "|" + METRICS_CPU[1];
			Double prevUsageInUsermode = cpuCache.get(cpuCacheUsageInUsermodeKey);
			String cpuCacheSystemCPUUsageKey = host + "|" + containerName + "|" + METRICS_CPU[2];
			Double prevSystemCPUUsage = cpuCache.get(cpuCacheSystemCPUUsageKey);
			Double totalCPUUsageDiff=null, systemCPUUsageDiff=null, usageInUsermodeDiff=null;
			if ( prevTotalCPUUsage == null || prevUsageInUsermode == null || prevSystemCPUUsage == null) {
				totalCPUUsageDiff = new Double(0);
				systemCPUUsageDiff = new Double(0);
				usageInUsermodeDiff = new Double(0);
			}
			else {
				totalCPUUsageDiff = new Double(Math.abs(totalUsage.doubleValue() - prevTotalCPUUsage.doubleValue()));
				systemCPUUsageDiff = new Double(Math.abs(systemUsage.doubleValue() - prevSystemCPUUsage.doubleValue()));
				usageInUsermodeDiff = new Double(Math.abs(userModeUsage.doubleValue() - prevUsageInUsermode.doubleValue()));
			}
			
			log.log(Level.FINER, "TotalCPU=" + totalUsage.doubleValue());
			log.log(Level.FINER, "UserMode=" + userModeUsage.doubleValue());
			log.log(Level.FINER, "SystemUsage=" + systemUsage.doubleValue());
			
			if ( prevTotalCPUUsage != null)
				log.log(Level.FINER, "PrevTotalCPU=" + prevTotalCPUUsage.doubleValue());

			if ( prevUsageInUsermode != null)
					log.log(Level.FINER, "PrevUserMode=" + prevUsageInUsermode.doubleValue());

			if ( prevSystemCPUUsage != null)
				log.log(Level.FINER, "PrevSystemUsage=" + prevSystemCPUUsage.doubleValue());

			log.log(Level.FINER, "TotalCPUDiff=" + totalCPUUsageDiff.doubleValue());
			log.log(Level.FINER, "UserModeDiff=" + usageInUsermodeDiff.doubleValue());
			log.log(Level.FINER, "SystemUsageDiff=" + systemCPUUsageDiff.doubleValue());

			cpuCache.put(cpuCacheTotalUsageKey, new Double(totalUsage.doubleValue()));
			cpuCache.put(cpuCacheUsageInUsermodeKey, new Double(userModeUsage.doubleValue()));
			cpuCache.put(cpuCacheSystemCPUUsageKey, new Double(systemUsage.doubleValue()));
			
			innerMap.put(METRICS_CPU[3], totalCPUUsageDiff);
			innerMap.put(METRICS_CPU[4], usageInUsermodeDiff);
			innerMap.put(METRICS_CPU[5], systemCPUUsageDiff);
			innerMap.put(METRICS_CPU[6], calculateCPUPercent(totalCPUUsageDiff, systemCPUUsageDiff, percpuUsage.size()));
			
		}	
		theMap.put("CPUGroup", innerMap);
	}

	private void getNetworkUsage(JsonNode node, Map<String,Map<String, Double>> theMap, String containerName, String host) {
		Map<String, Double> innerMap = new HashMap<String, Double>();
		JsonNode netStats = node.get("network");
		if (netStats != null) 
		{
			BigInteger rxBytes = getBigIntegerValue(METRICS_NETWORK[0], netStats);
			BigInteger txBytes = getBigIntegerValue(METRICS_NETWORK[1], netStats);
			BigInteger rxPacket = getBigIntegerValue(METRICS_NETWORK[2], netStats);
			BigInteger txPacket = getBigIntegerValue(METRICS_NETWORK[3], netStats);
			
			innerMap.put(METRICS_NETWORK[0], new Double(rxBytes.doubleValue()));
			innerMap.put(METRICS_NETWORK[1], new Double(txBytes.doubleValue()));
			innerMap.put(METRICS_NETWORK[2], new Double(rxPacket.doubleValue()));
			innerMap.put(METRICS_NETWORK[3], new Double(txPacket.doubleValue()));
			
			String rxBytesKey = host + "|" + containerName + "|" + METRICS_NETWORK[0];
			Double prevRxBytes = networkCache.get(rxBytesKey);
			String txBytesKey = host + "|" + containerName + "|" + METRICS_NETWORK[1];
			Double prevTxBytes = networkCache.get(txBytesKey);
			String rxPacketsKey = host + "|" + containerName + "|" + METRICS_NETWORK[2];
			Double prevRxPackets = networkCache.get(rxPacketsKey);
			String txPacketsKey = host + "|" + containerName + "|" + METRICS_NETWORK[3];
			Double prevTxPackets = networkCache.get(txPacketsKey);
			
			Double rxBytesDiff=null, txBytesDiff=null, rxPacketDiff=null, txPacketDiff=null;
			if ( prevRxBytes == null || prevTxBytes == null || prevRxPackets == null || prevTxPackets == null) {
				rxBytesDiff = new Double(0);
				txBytesDiff = new Double(0);
				rxPacketDiff = new Double(0);
				txPacketDiff = new Double(0);
			}
			else {
				rxBytesDiff = new Double(Math.abs(rxBytes.doubleValue() - prevRxBytes.doubleValue()));
				txBytesDiff = new Double(Math.abs(txBytes.doubleValue() - prevTxBytes.doubleValue()));
				rxPacketDiff = new Double(Math.abs(rxPacket.doubleValue() - prevRxPackets.doubleValue()));
				txPacketDiff = new Double(Math.abs(txPacket.doubleValue() - prevTxPackets.doubleValue()));
			}

			networkCache.put(rxBytesKey, new Double(rxBytes.doubleValue()));
			networkCache.put(txBytesKey, new Double(txBytes.doubleValue()));
			networkCache.put(rxPacketsKey, new Double(rxPacket.doubleValue()));
			networkCache.put(txPacketsKey, new Double(txPacket.doubleValue()));
			
			innerMap.put(METRICS_NETWORK[4], rxBytesDiff);
			innerMap.put(METRICS_NETWORK[5], txBytesDiff);
			innerMap.put(METRICS_NETWORK[6], rxPacketDiff);
			innerMap.put(METRICS_NETWORK[7], txPacketDiff);
		}
		theMap.put("NetworkGroup", innerMap);
	}
	
	private Double percentage(double i1, double i2)
	{
		double i1Value100 = i1 * 100;
		double result = i1Value100 / i2;
		DecimalFormat df = new DecimalFormat("####0.00");
		result = Double.valueOf(df.format(result));
		return new Double(result);
		
//		BigDecimal bigDecimal = new BigDecimal(i1).multiply(VALUE_100);
//		return new Double(bigDecimal.divide(new BigDecimal(i2), 2, RoundingMode.HALF_UP).setScale(0, 4).doubleValue());
	}

	private Double calculateCPUPercent(double totalCPUUsageDiff, double systemCPUUsageDiff, int percpuLen) {
		if ( totalCPUUsageDiff > 0 && systemCPUUsageDiff > 0) {
			double cpuPercent = (totalCPUUsageDiff / systemCPUUsageDiff) * (percpuLen * 100);
			DecimalFormat df = new DecimalFormat("####0.00");
			cpuPercent = Double.valueOf(df.format(cpuPercent));
			return new Double(cpuPercent);
		}
		return new Double(0);
	}
	
	private void populateDockerMetrics(Map<String, Map<String, Map<String, Map<String, Double>>>> allContainers, int totalContainerCount, int totalImageCount, MonitorEnvironment env) {
		Set<String> hostSet = allContainers.keySet();
		for (String hostName : hostSet) {	
			log.log(Level.FINE, "Processing host="+ hostName);
			Map<String, Map<String, Map<String, Double>>> containers = allContainers.get(hostName);
			Collection<MonitorMeasure> monitorMeasures = env.getMonitorMeasures("SummaryGroup", "dockerInstanceCount");
			for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures) {
				subscribedMonitorMeasure.setValue(totalContainerCount);
			}

			monitorMeasures = env.getMonitorMeasures("SummaryGroup", "dockerImageCount");
			for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures) {
				subscribedMonitorMeasure.setValue(totalImageCount);
			}

			Set<String> keySet = containers.keySet();
			log.log(Level.FINE, "size of the map=" + keySet.size());
			for (int index = 0; index < METRICS_CONTAINER_INFO.length; index++) {
				for (String key : keySet) {
					Map<String, Map<String, Double>> containerMap = containers.get(key);
					Map<String, Double> cpuMap = containerMap.get("CIGroup");
					monitorMeasures = env.getMonitorMeasures("CIGroup", METRICS_CONTAINER_INFO[index]);
					for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures) {
						MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Container Name", hostName + ":" + key);
						dynamicMeasure.setValue(cpuMap.get(METRICS_CONTAINER_INFO[index]));
					}
				}
			}

			keySet = containers.keySet();
			log.log(Level.FINE, "size of the map=" + keySet.size());
			for (int index = 0; index < METRICS_CPU.length; index++) {
				for (String key : keySet) {
					Map<String, Map<String, Double>> containerMap = containers.get(key);
					Map<String, Double> cpuMap = containerMap.get("CPUGroup");
					monitorMeasures = env.getMonitorMeasures("CPUGroup", METRICS_CPU[index]);
					for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures) {
						MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Container Name", hostName + ":" + key);
						dynamicMeasure.setValue(cpuMap.get(METRICS_CPU[index]));
					}
				}
			}

			// Populating Memory Stats
			keySet = containers.keySet();
			for (int index = 0; index < METRICS_MEMORY.length; index++) {
				for (String key : keySet) {
					Map<String, Map<String, Double>> containerMap = containers.get(key);
					Map<String, Double> memoryMap = containerMap.get("MemoryGroup");
					monitorMeasures = env.getMonitorMeasures("MemoryGroup", METRICS_MEMORY[index]);
					for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures) {
						MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Container Name", hostName + ":" + key);
						dynamicMeasure.setValue(memoryMap.get(METRICS_MEMORY[index]));
					}
				}
			}

			// Populating Network Stats
			log.log(Level.FINE, "Done with Memory.Starting Network");
			keySet = containers.keySet();
			for (int index = 0; index < METRICS_NETWORK.length; index++) {
				for (String key : keySet) {
					Map<String, Map<String, Double>> containerMap = containers.get(key);
					Map<String, Double> networkMap = containerMap.get("NetworkGroup");

					// If docker is deployed with Kubernetes, the network stats are not available and hence checking the size of the map.
					if (networkMap == null || networkMap.size() == 0) {
						continue;
					}
					monitorMeasures = env.getMonitorMeasures("NetworkGroup", METRICS_NETWORK[index]);
					for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures) {
						MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Container Name", hostName + ":" + key);
						dynamicMeasure.setValue(networkMap.get(METRICS_NETWORK[index]));
					}
				}
			}
		}
	}
	
/*	public static String loadLibrary() throws IOException {
		InputStream in = DockerMonitor.class.getClassLoader().getResourceAsStream("/res/libjunixsocket-linux-1.5-amd64.so");
		String tmpDir = System.getProperty("java.io.tmpdir");
		File socketSoFile = new File(tmpDir, "libjunixsocket-linux-1.5-amd64.so");
		FileOutputStream out = new FileOutputStream(socketSoFile);
		copy(in, out);
		in.close();
		out.close();
		return socketSoFile.getAbsolutePath();
	}
	
	public static final void copy(final InputStream in, final OutputStream out) throws IOException {
		final byte buffer[] = new byte[1024];
		int read = in.read(buffer, 0, buffer.length);
		while (read > 0) {
			out.write(buffer);
			read = in.read(buffer, 0, read);
		}
	}
*/
	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 *
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and
	 * <tt>teardown</tt> are called on different threads, but they are called
	 * sequentially. This means that the execution of these methods does not
	 * overlap, they are executed one after the other.
	 *
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt>
	 * ends -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout,
	 * <tt>execute</tt> stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is
	 * removed -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 *
	 *
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 *
	 * @see Monitor#setup(MonitorEnvironment)
	 */	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		// TODO
	}
}
